# Verilog单周期CPU设计报告

## 一，CPU设计方案综述

### （一）总体设计概述

​       本设计为由Verilog实现的最多支持1024条指令的单周期MIPS-CPU，支持addu，subu，ori，lw，sw，beq，lui，nop, jr, jal 这十条指令。为了实现这这些功能，本实验设计出的CPU被分为了IFU（指令存储单元），GRF（寄存器组），ALU（算术逻辑运算单元），DM（数据存储器），EXT（位扩展器），Controller（控制器），spliter（分解指令）这7个模块。

### （二）关键模块定义

#### 1.GRF

##### A 介绍

通用寄存器组，用于临时存放和调用数据，数据为32位。

##### B 端口定义

寄存器堆

| 端口  | 输入输出(位宽) |                   描述                    |
| :---: | :------------: | :---------------------------------------: |
|  RA1  |    I [4:0]     | 指定寄存器堆中的一个，将其中数据输出到RD1 |
|  RA2  |    I [4:0]     | 指定寄存器堆中的一个，将其中数据输出到RD2 |
|  WA   |    I [4:0]     |    指定32个寄存器中的一个，写入WD数据     |
|  WD   |    I [31:0]    |                输入的数据                 |
| reset |       I        |               异步复位端口                |
|  clk  |       I        |                 时钟信号                  |
|  WE   |       I        |      WE为1：可写入；WE为0，不可写入       |
|  RD1  |    O [31:0]    |             RA1指定寄存器的值             |
|  RD2  |    O [31:0]    |             RA2指定寄存器的值             |

##### C 功能介绍

| 功能名称 |                     功能描述                     |
| :------: | :----------------------------------------------: |
| 读入数据 |     当WE为1时，可以将WD写入WA指定的寄存器中      |
| 输出数据 | 可以将RA1和RA2指定的寄存器中的值通过RD1和RA2输出 |
|   复位   |          当reset信号为1时，实现异步复位          |

#### 2.DM

##### A 介绍

数据存储器，可以用于存放和调用数据。

##### B 端口定义

| 端口  | 输入输出（位宽） |        描述        |
| :---: | :--------------: | :----------------: |
| addr  |     I [5:0]      | 待写入（输出）地址 |
|  din  |     I [31:0]     |     待写入数据     |
| reset |        I         |    异步复位信号    |
|  clk  |        I         |      时钟信号      |
| Store |        I         |     写入使能端     |
| dout  |     O [31:0]     |      输出数据      |

##### C 功能定义

| 功能名称 |              功能描述               |
| :------: | :---------------------------------: |
| 读入数据 | 当WE为1且时钟上升沿到来时，写入数据 |
| 输出数据 |   将WA指定的内存中存储的数据输出    |
|   复位   |   当reset信号为1时，实现异步复位    |

#### 3.ALU

##### A 介绍

算数逻辑运算单元，用于实现指令执行过程中所需要的数学运算

##### B 端口定义

| 端口 | 输入输出（位宽） |         描述         |
| :--: | :--------------: | :------------------: |
|  A   |     I [31:0]     | 参与运算的第一个数据 |
|  B   |     I [31:0]     | 参与运算的第二个数据 |
|  Op  |     I [2:0]      | 000:+  001:-  010:\| |
|  C   |     O [31:0]     |       运算结果       |
| zero |        O         |   C是0为1，否则为0   |

##### C 功能定义

| 功能名称 |                    功能描述                    |
| :------: | :--------------------------------------------: |
| 数学运算 | 将输入的A，B值按照Op的值进行二元运算，输出结果 |
|   判0    |              判断运算结果是否为0               |

#### 4.IFU

##### A 介绍

指令存储单元，内部涵盖指令计数器（PC）和指令寄存器（IM），用于取出当前执行的指令和存放下一个指令。

##### B 端口定义

|  端口  | 输出输出（位宽） |         描述         |
| :----: | :--------------: | :------------------: |
| nextPC |     I [31:0]     |    下一条指令地址    |
|  clk   |        I         |       时钟信号       |
| reset  |        I         |     异步复位信号     |
|  intr  |     O [31:0]     | 从IM中取出的当前指令 |
|   PC   |     O [31:0]     |     当前指令地址     |

##### C 功能定义

| 功能名称 |              功能描述              |
| :------: | :--------------------------------: |
|  取指令  |   将当前指令取出用于后续逻辑处理   |
|  存指令  | 将处理后的写一条指令地址存入nextPC |
|   复位   |    当reset信号为1，PC回归32b'0     |

#### 5.EXT

##### A 介绍

用于进行位扩展操作，主要用于将16位立即数扩展成32位

##### B 端口定义

|  端口  | 输入输出（位宽） |             描述             |
| :----: | :--------------: | :--------------------------: |
|   in   |     I [16:0]     |        输入16位立即数        |
|  sign  |     I [31:0]     |     输出符号扩展后的数据     |
| unsign |     I [31:0]     |    输出无符号扩展后的数据    |
| bigimm |     I [31:0]     | 输出将立即数低位扩展后的数据 |

##### C 功能定义

|  功能名称  |            功能描述             |
| :--------: | :-----------------------------: |
| 无符号扩展 |     对立即数进行无符号扩展      |
| 有符号扩展 |     对立即数进行有符号扩展      |
|  低位扩展  | 将立即数加载到高16位，低位补充0 |

#### 6.Controller

##### A 介绍

中心控制器，用于产生支持各条指令数据通路的片选和控制信号。

##### B 端口定义

|   端口   | 输入输出（位宽） |           描述           |
| :------: | :--------------: | :----------------------: |
|    op    |     I [5:0]      |   每条指令的六位操作码   |
|   fuc    |     I [5:0]      |   每条指令的六位功能码   |
|  WDctrl  |     O [1:0]      |    寄存器写入选择信号    |
| ALUctrl  |     O [1:0]      |    ALU B端口选择信号     |
| MemWrite |        O         |  是否向存储器中写入数据  |
| RegWrite |        O         | 是否向寄存器堆中写入数据 |
|  RegDst  |     O [1:0]      |    寄存器写入地址选择    |
|  ALUOp   |     O [1:0]      |   ALU运算模式选择信号    |
|  PCctrl  |     O [1:0]      |      nextPC选择信号      |

##### C 功能定义（真值表）

|          |  nop   |  addu  |  subu  |   lw   |   sw   |  beq   |  jal   |   jr   |  lui   |  ori   |
| :------: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
|    op    | 000000 | 000000 | 000000 | 100011 | 101011 | 000100 | 000011 | 000000 | 001111 | 001101 |
| function | 000000 | 100001 | 100011 |   略   |   略   |   略   |   略   | 001000 |   略   |   略   |
|  WDctrl  |   00   |   00   |   00   |   01   |   00   |   00   |   10   |   00   |   11   |   00   |
| ALUctrl  |   00   |   00   |   00   |   01   |   01   |   00   |   00   |   00   |   00   |   10   |
| MemWrite |   0    |   0    |   0    |   0    |   1    |   0    |   0    |   0    |   0    |   0    |
| RegWrite |   0    |   1    |   1    |   1    |   0    |   0    |   1    |   0    |   1    |   1    |
|  RegDst  |   00   |   10   |   10   |   00   |   00   |   00   |   01   |   00   |   00   |   00   |
|  ALUOp   |  000   |  000   |  001   |  000   |  000   |  001   |  000   |  000   |  000   |  010   |
|  PCctrl  |   11   |   11   |   11   |   11   |   11   |   01   |   10   |   00   |   11   |   11   |

#### 7.spliter

##### A 介绍

用于将32位指令代码分解成易于处理的众多模块。

##### B 端口定义

|   端口   | 输入输出（位宽） |       描述        |
| :------: | :--------------: | :---------------: |
|   intr   |     I [31:0]     |     输入指令      |
|   imm    |     O [15:0]     |    15位立即数     |
| function |     O [5:0]      |     6位功能码     |
|    rd    |     O [4:0]      | 寄存器堆输入地址  |
|    rt    |     O [4:0]      | 寄存器堆操作地址1 |
|    rs    |     O [4:0]      | 寄存器堆操作地址2 |
|    op    |     O [4:0]      |     6位操作码     |

##### C 功能定义

| 功能名称 |                    功能描述                     |
| :------: | :---------------------------------------------: |
| 分解指令 | 将32位指令代码分解成imm,function,rs,rt,rd,op和j |

### （三）重要机制及其实现方法

#### 1 数据通路&&控制信号搭建

  首先列出数据通路表，然后进行合并，实现时在中心模块下用assign+三目运算符进行连线。

  在控制信号模块直接判断指令的种类，然后对控制信号用三目运算符的方式进行编码。



## 二，测试方案

### （一）典型样例测试

#### 1 综合测试数据

![QQ图片20201115164657](D:\verilog\p4\设计文档\QQ图片20201115164657.png)

运行结果：

![QQ图片20201115164914](D:\verilog\p4\设计文档\QQ图片20201115164914.png)

符合预期。

### （二）自动化生成测试数据

使用c++程序编程实现。

```c++
#include <bits/stdc++.h>

using namespace std;

vector<int> r;
mt19937 mt(time(0));
uniform_int_distribution<int> 
	imm16(0, (1 << 16) - 1), 
	siz(0, 1023), 
	reg(0, 2), 
	grf(1, 30),
	I(1, 6),
	J(7, 9),
	IJ(1, 9);
	
int cnt;

void solve(int);

int getR(){
	return r[reg(mt)];
}

void addu(){
	printf("addu $%d, $%d, $%d\n", getR(), getR(), getR());
}

void subu(){
	printf("subu $%d, $%d, $%d\n", getR(), getR(), getR());
}

void ori(){
	printf("ori $%d, $%d, %d\n", getR(), getR(), imm16(mt));
}

void lw(){
	printf("lw $%d, %d($0)\n", getR(), siz(mt) * 4);
}

void sw(){
	printf("sw $%d, %d($0)\n", getR(), siz(mt) * 4);
}

void lui(){
	printf("lui $%d, %d\n", getR(), imm16(mt));
}

void beq(){
	printf("beq $%d, $%d, label%d\n", getR(), getR(), ++cnt);
	solve(I(mt));
	solve(I(mt));
	solve(I(mt));
	printf("label%d: ", cnt);
	solve(I(mt));
}

void jaljr(){
	int x = getR();
	printf("ori $%d $0 16\n",x);
	printf("jal label%d\n", ++cnt);
	solve(I(mt));
	solve(I(mt));
	printf("label%d:", cnt);
	printf("addu $%d, $%d, $31\n", x, x);
	printf("jr $%d\n", x);
	solve(I(mt));
}

void j(){
	printf("j label%d\n", ++cnt);
	solve(I(mt));
	solve(I(mt));
	solve(I(mt));
	printf("label%d: ", cnt);
	solve(I(mt));
}

void solve(int i){
	switch(i){
		case 1:
			addu();
			break;
		case 2:
			subu();
			break;
		case 3:
			ori();
			break;
		case 4:
			lw();
			break;
		case 5:
			sw();
			break;
		case 6:
			lui();
			break;
		case 7:
			beq();
			break;	
		case 8:
			jaljr();
			break;
		case 9:
			j();
			break;						 
	}
}

int main(){
	r.push_back(grf(mt)), r.push_back(grf(mt)), r.push_back(grf(mt));
	freopen("test.asm", "w", stdout);
	puts("ori $28, $0, 0");
	puts("ori $29, $0, 0");
	for(int i = 1;i <= 700;i++){
		int x = IJ(mt);
		if(x > 6) i += 5;
		solve(x);
	}
}
```

### 3 自动化测试方案

先用上述程序生成测试代码写入test.asm，将test.asm导入魔改mars，输出到m.out，再将机器码导出到code.txt，再利用iverilog将test.v的输出写入v.out,最后分别对文件进行排序，比对，将比对结果输出到check.txt，跳回最开始开始循环。

![p1](D:\verilog\p4\设计文档\p1.png)

## 三，思考题

### （一）根据你的理解，在下面给出的DM的输入示例中，地址信号addr位数为什么是[11:2]而不是[9:0]？这个addr信号又是从哪里来的？

![img](http://cscore.net.cn/assets/courseware/v1/c56b0b6aad72fb754f3712ddd75d4b42/asset-v1:Internal+B3I062410+2020_T1+type@asset+block/P4_L0_T2_5new.png)

 * 因为DM中存储器一个字占一个地址，然而mips-cpu中默认一个字节占一个地址，所以这里需要把DM输入地址（ALUout）的11到2位作为输出，相当于对地址做一个除4操作。
 * addr信号的来源固定是算术逻辑运算单元的输出ALUout。

### （二）思考Verilog语言设计控制器的译码方式，给出代码示例，并尝试对比各方式的优劣。

* 一共有两种方式

  * **指令对应的控制信号如何取值**：

    ``` verilog
    if(ori) begin
        WDctrl=0;
        ALUctrl=2;
        MemWrite=0;
        RegWrite=1;
        RegDst=0;
        ALUOp=2;
        PCctrl=3;
    end
    ```

    这种方式比较有针对性，对每个指令数据通路需求的控制信号展现的较为全面，不容易出错，但是修改起来比较麻烦，不够简洁。再后续添加指令后容易使代码变得冗长。

  * **控制信号每种取值所对应的指令**:

    ```verilog
    assign ALUctrl=(ori)? 2:
                   (lw||sw)?1:
    				0;
    ```

    这种方式比较简便，利用了真值表的方法避免了穷举的麻烦，而且后续经行修改添加的操作时也十分简便，但是这种方法比较容易出错。

### （三）在相应的部件中，**reset的优先级**比其他控制信号（不包括clk信号）都要**高**，且相应的设计都是**同步复位**。清零信号reset所驱动的部件具有什么共同特点？

* 这些部件都具有时序特征，可以对数据进行存储和提取，都可以在时钟上升沿到来时，在对应的位置（地址）存储输入的值。

### （四）C语言是一种弱类型程序设计语言。C语言中不对计算结果溢出进行处理，这意味着C语言要求程序员必须很清楚计算结果是否会导致溢出。因此，如果仅仅支持C语言，MIPS指令的所有计算指令均可以忽略溢出。 请说明为什么在忽略溢出的前提下，addi与addiu是等价的，add与addu是等价的。提示：阅读《MIPS32® Architecture For Programmers Volume II: The MIPS32® Instruction Set》中相关指令的Operation部分 。

* 因为addi相对于addiu，add相对于addu多判断了一个结果是否溢出，所以在忽略溢出的情况下，add和addu，addi和addiu是等价的。

### （五）根据自己的设计说明单周期处理器的优缺点

* 优点：逻辑相对比较简单，易于实现，处理结果比较精确，不容易出错。
* 缺点：效率比较低，运行指令速度较慢，无法适应工程化要求。



   

